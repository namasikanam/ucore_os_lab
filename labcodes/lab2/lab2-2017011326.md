# Lab2 实验报告

## 练习1

在着手写代码前，我首先通过阅读文档、注释和已有代码对自己要写的部分有了大致的了解，再着手开始写代码。核心思路是保证页链表的地址是保序的，在保证此性质的前提下实现了一个简易的线性内存分配和释放算法。

Q: 你的 first fit 算法是否有进一步的改进空间

是的，现有的 FFMA 的插入和删除操作都是线性的时间复杂度，可引入块状链表（根号级）或跳表（指数级）提升效率。

## 练习2

在仔细阅读文档和注释之后，我开始基于引导注释写代码。

实现中，主要遇到了这样一个问题：memset中应当给出虚拟地址、还是物理地址？

参考标准代码之后得知，应当是虚拟地址。

Q1: 请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中每个组成部分的含义以及对 ucore 而言的潜在用处。

PDE的第12~31位是该PDE所描述的二级页表所在的页的起始物理地址，PTE的第12~31位是该PTE所描述的页的起始物理地址，其余位的功能通过阅读`kern/mm/mmu.h`中的相关代码可知如下：
- 第0位：`PTE_P`，该表项是否存在
- 第1位：`PTE_W`，所描述的页是否可写
- 第2位：`PTE_U`，用户态是否对所描述的页拥有读权限
- 第3位：`PTE_PWT`，所描述的页的写策略是Write Through
- 第4位：`PTE_PCD`，是否禁止缓存
- 第5位：`PTE_A`，是否被访问过
- 第6位：`PTE_D`，是否被写过
- 第7位：`PTE_PS`，页大小（必须为0）
- 第8位：必须为0
- 第9-11位：保留给软件使用，内核和硬件不对其作任何利用和解释

Q2: 如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

A. 在内存中有空闲物理页面时，分配一物理页帧f，转第E步；

B. 依据页面置换算法选择将被替换的物理页帧f，对应逻辑页q；

C. 如q被修改过，则把它写回外存；

D. 修改q的页表项中驻留位置为0；

E. 将需要访问的页p装入到物理页面f；

F. 修改p的页表项驻留位为1,物理页帧号为f；

G. 重新执行产生缺页的指令。

参考自[OS2019-08-07 缺页异常.pptx](http://os.cs.tsinghua.edu.cn/oscourse/OS2015/lecture08?action=AttachFile&do=get&target=os-08-07%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8.pptx)。

## 练习3

在仔细阅读文档之后，我开始基于帮助注释实现代码。

相比于页插入，页删除要简单很多，帮助注释已经非常清晰。


Q1: 数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？

有的。Page描述了一个物理页。

每一个合法的页目录项都对应于一个Page，即其所描述的二级页表所在的物理页。同样，每一个合法的页表项也对应一个Page，即其所描述的物理页。

反过来看，一级页表所对应的Page不会被页表项或页目录项所描述；一个Page不能同时被页表项和页目录项所描述；一个Page至多被一个页目录项所描述，但可以被任意多个页表项所描述。

Q2: 如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？ 鼓励通过编程来具体完成这个问题

需要修改[地址映射的第二个阶段](https://chyyuu.gitbooks.io/ucore_os_docs/lab2/lab2_3_3_5_4_maping_relations.html)，避免内核移到高虚拟地址。具体而言，需要将`KERNBASE`设为0x0，并进一步更正之后其造成的其他影响。

## 总结

### 本实验中涉及的知识点

- 页式内存分配
- FFMA 算法
- 段页式存储空间管理
- 逻辑地址与物理地址的转换
- 多级页表

### 本实验中过早涉及的知识点

- 缺页异常：在[OS2019 Lecture08](http://os.cs.tsinghua.edu.cn/oscourse/OS2019spring/lecture08)中方才讲到。