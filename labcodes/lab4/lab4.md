# Lab4 实验报告

## 练习1

帮助注释和文档对于应当如何初始化并没有说得十分清晰，我不得不参考标准代码来实现。

不过，我认为标准代码有一点疏忽：`proc->name`是一个`char[PROC_NAME_LEN + 1]`，标准代码应当对整个`char[]`清零，然而其只对前`PROC_NAME_LEN`个字节清零了。

Q: 请说明`proc_struct`中`struct context context`和`struct trapframe *tf`成员变量含义和在本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来）

- `struct context context`：进程的上下文，即进程切换过程（`kern/process/switch.S`中的`switch_to`）中应当保存的寄存器。
- `struct trapframe *tf`：中断帧的指针，总是指向内核栈的某个位置：当进程从用户空间跳到内核空间时，中断帧记录了进程在被中断前的状态。当内核需要跳回用户空间时，需要调整中断帧以恢复让进程继续执行的各寄存器值。

## 练习2

通过阅读帮助注释和文档实现代码。

在学习了参考代码之后，我的代码与参考代码有以下几点不同：
- 参考代码中对于出错的情况并未输出相应的错误信息。
- 参考代码中中，在获取PID和加进程加入链表的操作时，关闭了IRQ。

Q：请说明 ucore 是否做到给每个新 fork 的线程一个唯一的 id？请说明你的分析和理由。

可以。因为在调用`getpid`时关闭了IRQ，保证了取得 id 时操作的原子性。

## 练习3

`proc_run`用于原子性地跑起进程`proc`，具体流程如下：
1. 让`current`指向`next`；
2. 设置任务状态段`ts`中特权态 0 下的栈顶指针`esp0`为`next`内核线程的内核栈的栈顶，即`next->kstack + KSTACKSIZE`；
3. 设置`CR3`寄存器的值为`next`内核线程的页目录表起始地址`next->cr3`，这实际上是完成进程间的页表切换；
4. 由`switch_to`函数完成具体的两个线程的执行现场切换，即切换各个寄存器，当`switch_to`函数执行完`ret`指令后，就切换到`next`执行了。

并回答如下问题：

Q: 在本实验的执行过程中，创建且运行了几个内核线程？

2个。

Q: 语句`local_intr_save(intr_flag);....local_intr_restore(intr_flag);`在这里有何作用？请说明理由。

关闭IRQ使能，保证操作原子性。

## 总结

- 进程创建
- 进程切换
- 进程与线程的区别