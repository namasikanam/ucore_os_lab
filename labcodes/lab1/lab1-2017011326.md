# Lab1 实验报告

## 练习1

Q1：操作系统镜像文件 ucore.img 是如何一步一步生成的？(需要比较详细地解释 Makefile 中每一条相关命令和命令参数的含义，以及说明命令导致的结果)

```makefile

KINCLUDE	+= kern/debug/ \
			   kern/driver/ \
			   kern/trap/ \
			   kern/mm/

KSRCDIR		+= kern/init \
			   kern/libs \
			   kern/debug \
			   kern/driver \
			   kern/trap \
			   kern/mm

KCFLAGS		+= $(addprefix -I,$(KINCLUDE))

# 批量生成 .o 文件
$(call add_files_cc,$(call listf_cc,$(KSRCDIR)),kernel,$(KCFLAGS))

KOBJS	= $(call read_packet,kernel libs)

# 得到 kernel 的准确相对路径 bin/kernel
kernel = $(call totarget,kernel)

# 
$(kernel): tools/kernel.ld

$(kernel): $(KOBJS)
	@echo + ld $@
    # ld -m    elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/stdio.o obj/kern/libs/readline.o obj/kern/debug/panic.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/picirq.o obj/kern/driver/intr.o obj/kern/trap/trap.o obj/kern/trap/vectors.o obj/kern/trap/trapentry.o obj/kern/mm/pmm.o  obj/libs/string.o obj/libs/printfmt.o
    # -m elf_i386 模仿 elf_i386 链接器。
    # -nostdlib 只搜索在命令行中显式声明的库目录。
    # -T tools/kernel.ld 用 tools/kernel.ld 作为链接脚本
	$(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS)
    # objdump -S bin/kernel
	@$(OBJDUMP) -S $@ > $(call asmfile,kernel)
    # objdump -t bin/kernel
	@$(OBJDUMP) -t $@ | $(SED) '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $(call symfile,kernel)

# -------------------------------------------------------------------

# bootfiles 包括 bootasm 和 bootmain
bootfiles = $(call listf_cc,boot)

# gcc -Iboot/ -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o
# gcc -Iboot/ -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootmain.c -o obj/boot/bootmain.o
# -Iboot/ 将 boot/ 加入到预处理时搜索头文件的目录列表中
# -march i686 目标架构是 i686
# -fno-builtin 只将以 __builtin__ 开头的函数视为内置函数
# -fno-PIC 在 x86 环境下无影响
# -m32 在 x86 的机器上，表示生成32位环境下的代码
# -gstabs 生成stabs格式的调试信息（如果支持该格式的话），忽略GDB的特有扩展
# -nostdinc 不在标准系统文件夹中搜索头文件
# -fno-stack-protector 不检查缓冲区溢出
# -Ilibs/ 将 libs/ 加入到预处理时搜索头文件的目录列表中
# -Os 依据代码大小来优化
$(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),$(CFLAGS) -Os -nostdinc))

# 得到 bootblock 的准确相对路径 bin/bootblock
bootblock = $(call totarget,bootblock)

# 构建 bootblock
$(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign)
	@echo + ld $@
    # ld -m    elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o
    # -m elf_i386 模仿 elf_i386 链接器。
    # -nostdlib 只搜索在命令行中显式声明的库目录。
    # -N 将text段和data段设为可读和可写的。
    # -e start 用 start 作为用于程序执行的显式符号，以替换此前的默认进入节点。
    # -Ttext 0x7c00 指定text段的开始位置为0x7c00
    # 将 obj/boot/bootasm.o 和 obj/boot/bootmain.o 链接起来，作为 obj/bootblock.o
	$(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ -o $(call toobj,bootblock)
    # objdump -S obj/bootblock.o > obj/bootblock.asm
    # -S 表示输出混有反汇编的源代码
    # 从 bootblock.o 中抓取信息放到 bootblock.asm
	@$(OBJDUMP) -S $(call objfile,bootblock) > $(call asmfile,bootblock)
    # objcopy -S -O binary obj/bootblock.o obj/bootblock.out
    # -S 表示不从源代码中复制重定位和符号信息
    # -O binary 表示以 binary 格式写输出文件
    # 用 objcopy 将 bootblock.o 转成binary格式的 bootblock.out
	@$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock)
    # bin/sign obj/bootblock.out bin/bootblock
    # 用 sign 将 bootblock.out 转成最终的执行文件 bootblock
	@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)

# -------------------------------------------------------------------

# gcc -Itools/ -g -Wall -O2 -c tools/sign.c -o obj/sign/tools/sign.o
# -I tools/ 将 tools/ 加入到预处理时搜索头文件的目录列表中
# 生成 sign.o
$(call add_files_host,tools/sign.c,sign,sign)

# gcc -g -Wall -O2 obj/sign/tools/sign.o -o bin/sign
# 生成 sign
$(call create_target_host,sign,sign)

# -------------------------------------------------------------------

# 得到 UCOREIMG 的准确相对路径 bin/ucore.img
UCOREIMG	:= $(call totarget,ucore.img)

# 生成 bin/ucore.img
$(UCOREIMG): $(kernel) $(bootblock)
    # dd if=/dev/zero of=bin/ucore.img count=10000
    # if 是输入文件
    # of 是输出文件
    # count 是输入的块的上限
    # 这里用10000块 0 来填充 ucore.img 作为初始化
	$(V)dd if=/dev/zero of=$@ count=10000
    # dd if=bin/bootblock of=bin/ucore.img conv=notrunc
    # notrunc 表示不会依据输入文件的长度来对输出文件作截断
    # 这里将 bootblock 拷贝进 ucore 中
	$(V)dd if=$(bootblock) of=$@ conv=notrunc
    # dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc
    # seek=1 表示跳过输出文件的第1块，因为这部分已经拷贝进 bookblock 了
    # 从第2块开始，将 kernel 也复制到 ucore.img 中
	$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc
```

Q2: 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？

从sign.c的代码来看，一个磁盘主引导扇区只有512字节。且
- 第510个（倒数第二个）字节是0x55，
- 第511个（倒数第一个）字节是0xAA。

其关键代码部分见：
```c++
if (st.st_size > 510) {
    fprintf(stderr, "%lld >> 510!!\n", (long long)st.st_size);
    return -1;
}
// ...
buf[510] = 0x55;
buf[511] = 0xAA;
```

## 练习2

1. 在一个bash中开启qemu
```bash
qemu -S -s -d in_asm -D q.log -monitor stdio -hda bin/ucore.img -serial null -curses
```
2. 在另一个bash中开启gdb并连接qemu
```bash
target remote:1234
file bin/kernel
file obj/bootblock.o
```
3. 在gdb中设置断点并开始单步调试
```bash
break *0x7c00
c
si
...
```
4. 可以看到其反汇编代码与 bootblock.S 和 bootblock.asm 中的相同。在 q.log 中，可以看到从 0x7c00 开始的一段机器码：
```as
IN: 
0x0000000000007c00:  cli    

----------------
IN: 
0x0000000000007c00:  cli    

----------------
IN: 
0x0000000000007c01:  cld    

----------------
IN: 
0x0000000000007c02:  xor    %ax,%ax
0x0000000000007c04:  mov    %ax,%ds
0x0000000000007c06:  mov    %ax,%es
0x0000000000007c08:  mov    %ax,%ss
```

---

由于我没有，与参考答案有以下几点不同：
- 由于我没有配置GUI，故我的 qemu 需要在 terminal 中呈现。
- 我直接使用的 x86 的 qemu 模拟器，不需要再将指令集设为 i8086。

## 练习3



## 练习4

## 练习5

## 练习6

## 扩展练习1

## 扩展练习2

## Plan (To Be Deleted)

1. 填写各个基本练习中要求完成的报告内容
2. 完成实验后，请分析 ucore_lab 中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
3. 列出你认为本实验中重要的知识点，以及与对应的 OS 原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
4. 列出你认为 OS 原理中很重要，但在实验中没有对应上的知识点